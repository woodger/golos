# Тестовое задание

Необходимо создать простой веб-сервер на основе `ExpressJS`.
Сервер должен содержать такое апи:

## Простой пинг сервера

```
Клиент -> GET запрос на localhost:8080/hello
Сервер <- Простой текст «Привет»
```

## Пинг сервера с JSON

```
Клиент -> GET запрос на localhost:8080/hello_json
Сервер <- Ответ в виде JSON {«hello»: «world»}
```

Идеально будет если будут верно проставлены заголовки что это не просто текст, а именно `JSON`.

## Работа с Cookies

```
Клиент -> GET запрос на localhost:8080/hello_cookies
Сервер <- Возвращает такой же ответ что и в /hello, но также проставляет cookies со значением hello=world.
```

Идеально будет если куки будет помечены как `httpOnly` и к ним будет невозможно получить доступ из браузера.
> Дополнительно:
Если при запросе на этот адрес клиент отправляет уже проставленные куки `hello=world` - сервер должен вывести в консоль сообщение `'cookies done'` и удалить куки у этого клиента.

## Асинхронная работа

```
Клиент -> GET запрос на localhost:8080/wait_5_seconds
Сервер <- Сервер должен подождать 5 секунд и отправить клиенту ответ «done».
```

При этом, если отправить другой запрос (например из другой вкладки браузера, например на `/hello`) такие запросы должны быть обработаны незамедлительно, то есть сервер должен спать только для запроса на `/wait_5_seconds`.

## Калькулятор с валидацией

```
Клиент -> GET запрос на localhost:8080/calc?a=1&b=2&operator=plus
А и Б - любые числа, но только целые, оператор - один из списка - plus, minus, div, mul.
Сервер <- Ответом должен быть результат вычислений.
```

При этом если отправлен один из параметров или значение не верно (не верный оператор или вместо числа строка, или число дробное) - необходимо отвечать текстом с описанием что пошло не так и, обязательно, указывать код ошибки в `HTTP Status Code`. При этом если не хватает одного из параметров - код статуса `HTTP` один, а для ошибки в параметрах другой.

## Отсечка нагрузки на калькулятор

```
Клиент -> POST запрос на localhost:8080/calc_ddos
Параметры -> a, b, operator
Сервер <- Ответом должен быть результат вычислений.
```

Полный аналог калькулятора выше, но через POST запросы и в случае если за 10 секунд пришло более 5 запросов - необходимо возвращать сообщение с ошибкой.

> Дополнительно:
Кешировать уже вычисленные результаты и если такие параметры в запросе уже были - возвращать сохраненный ранее ответ вместо вычисления заново.

## Одноразовый читатель файлов

```
Клиент -> GET запрос на localhost:8080/read_once?file=name
file является именем файла из папки content, которая должна находится рядом с основным файлом сервера
Сервер <- Поток.
```
Сервер должен отправить текст из указанного файла, при этом прочитать его потоково, а после завершения отправки - удалить файл.

## Долго выполняющиеся запросы

```
Клиент -> GET запрос на localhost:8080/hello_wait_entity?id=1
id может быть любым числом.
Клиент -> GET запрос на localhost:8080/hello_wait_entity?key=key
```

key может быть любым уникальным ключом.
Сервер <- Один из ответов, описанных ниже.

При первом запросе с конкретным значением entity сервер должен вернуть случайно сгенерированный уникальный ключ (любым способом, например перемножением случайных чисел, главное чтобы он был уникальным). При последующих запросах с тем же `entity` должен приходить ответ с `HTTP` кодом 208, означающий что сервер более не
принимает подобных запросов.
Соответственно на каждый новый `entity` на сервере должен создаваться таймаут на `10 секунд`. В это время мы можем слать запросы второго типа с параметром key, который получили при запросе с `entity`. Если таймаут ещё не завершен мы должны получить ответ `'wait'`, а если завершен, то ответ `'done'`. Если такого ключа не существует - сообщение об ошибке с кодом 404.

> Дополнительно:
**GET** запрос на `localhost:8080/hello_wait_list` вернет список всех ключей, для которых таймауты ещё не завершились, а **GET** запрос на localhost:8080/hello_wait_done вернет список всех ключей, для которых таймауты уже завершены, в обоих случаях данные в виде `JSON`.
